{"version":3,"sources":["../yjs/node_modules/browserify/node_modules/browser-pack/_prelude.js","src/Xml.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"y-xml.es6","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* global Y, MutationObserver */\n'use strict'\n\nfunction extend (Y) {\n  Y.requestModules(['Array', 'Map']).then(function () {\n    class YXml extends Y.Array.typeDefinition['class'] {\n      constructor (os, _model, _content, attributes, tagname, init) {\n        super(os, _model, _content)\n        this.attributes = attributes\n        this.dom = null\n        this._domObserver = null\n        this._eventListenerHandler = new Y.utils.EventListenerHandler()\n        this.tagname = tagname\n        if (init != null && init.dom != null) {\n          this._setDom(init.dom)\n        }\n        super.observe(events => {\n          var userEvents = []\n          events.forEach(event => {\n            if (event.type === 'insert') {\n              userEvents.push({\n                type: 'childInserted',\n                index: event.index,\n                node: event.value,\n                valueId: event.valueId\n              })\n            } else if (event.type === 'delete') {\n              userEvents.push({\n                type: 'childRemoved',\n                index: event.index,\n                _content: event._content,\n                value: event.value\n              })\n            }\n          })\n          if (userEvents.length > 0) {\n            this._eventListenerHandler.callEventListeners(userEvents)\n          }\n        })\n        attributes.observe(events => {\n          var userEvents = []\n          events.forEach(event => {\n            if (event.type === 'update' || event.type === 'add') {\n              userEvents.push({\n                type: 'attributeChanged',\n                name: event.name,\n                value: event.value\n              })\n            } else if (event.type === 'delete') {\n              userEvents.push({\n                type: 'attributeRemoved',\n                name: event.name\n              })\n            }\n          })\n          if (userEvents.length > 0) {\n            this._eventListenerHandler.callEventListeners(userEvents)\n          }\n        })\n      }\n      _destroy () {\n        if (this._domObserver != null) {\n          this._domObserver.disconnect()\n        }\n        this._eventListenerHandler.destroy()\n        this._eventListenerHandler = null\n        super._destroy()\n      }\n      insert (pos, types) {\n        if (!Array.isArray(types)) {\n          throw new Error('Expected an Array of content!')\n        }\n        types.forEach(function (v) {\n          var t = Y.utils.isTypeDefinition(v)\n          if (!(v && (\n                       typeof v === 'string' ||\n                       (t && t[0].class === YXml)\n             ))) {\n            throw new Error('Expected Y.Xml type or String!')\n          }\n        })\n        super.insert(pos, types)\n      }\n      // binds to a dom element\n      // Only call if dom and YXml are isomorph\n      _bindToDom (dom) {\n        return new Promise(resolve => {\n          // this function makes sure that either the\n          // dom event is executed, or the yjs observer is executed\n          var token = true\n          var mutualExclude = f => {\n            // take and process current records\n            var records = this._domObserver.takeRecords()\n            if (records.length > 0) {\n              this._domObserverListener(records)\n            }\n            if (token) {\n              token = false\n              try {\n                f()\n              } catch (e) {\n                // discard created records\n                this._domObserver.takeRecords()\n                token = true\n                throw e\n              }\n              this._domObserver.takeRecords()\n              token = true\n            }\n          }\n          this._mutualExclude = mutualExclude\n          this._domObserverListener = mutations => {\n            mutualExclude(() => {\n              mutations.forEach(mutation => {\n                if (mutation.type === 'attributes') {\n                  this.attributes.set(mutation.attributeName, mutation.target.getAttribute(mutation.attributeName))\n                } else if (mutation.type === 'childList') {\n                  Array.prototype.forEach.call(Array.prototype.reverse.call(mutation.addedNodes), n => {\n                    // compute position\n                    var pos\n                    if (n.nextSibling == null) {\n                      pos = this._content.length\n                    } else {\n                      pos = this._content.findIndex(function (c) { return c.dom === n.nextSibling })\n                    }\n                    var c\n                    if (n instanceof window.Text) {\n                      c = n.textContent\n                    } else if (n instanceof window.Element) {\n                      c = Y.Xml(n)\n                    } else {\n                      throw new Error('Unsupported XML Element found. Synchronization will no longer work!')\n                    }\n                    this.insert(pos, [c])\n                    var content = this._content[pos]\n                    content.dom = n\n                    content.isInserted = true\n                    _tryInsertDom(pos - 1)\n                  })\n                  Array.prototype.forEach.call(mutation.removedNodes, n => {\n                    var pos = this._content.findIndex(function (c) {\n                      return c.dom === n\n                    })\n                    this.delete(pos)\n                  })\n                }\n              })\n            })\n          }\n          this._domObserver = new MutationObserver(this._domObserverListener)\n          this._domObserver.observe(dom, { attributes: true, childList: true })\n          // In order to insert a new node, successor needs to be inserted\n          // when c.dom can be inserted, try to insert the predecessors too\n          var _tryInsertDom = (pos) => {\n            var c = this._content[pos]\n            var succ\n            if (pos + 1 < this._content.length) {\n              succ = this._content[pos + 1]\n            } else {\n              // pseudo successor\n              succ = {\n                isInserted: true,\n                dom: null\n              }\n            }\n            while (pos >= 0 && succ.isInserted && c.dom != null && !c.isInserted) {\n              dom.insertBefore(c.dom, succ.dom)\n              c.isInserted = true\n              succ = c\n              c = this._content[--pos]\n            }\n          }\n          this._tryInsertDom = _tryInsertDom\n          this.observe(events => {\n            mutualExclude(() => {\n              events.sort(function (a, b) {\n                return a.index < b.index\n              }).forEach(event => {\n                if (event.type === 'attributeChanged') {\n                  dom.setAttribute(event.name, event.value)\n                } else if (event.type === 'attributeRemoved') {\n                  dom.removeAttribute(event.name)\n                } else if (event.type === 'childInserted') {\n                  if (typeof event.node === 'string') {\n                    var textNode = new window.Text(event.node)\n                    this._content[event.index].dom = textNode\n                    _tryInsertDom(event.index)\n                  } else {\n                    event.node().then(xml => {\n                      return xml.getDom()\n                    }).then(newNode => {\n                      mutualExclude(() => {\n                        // This is called async. So we have to compute the position again\n                        // also mutual excluse this\n                        var pos = this._content.findIndex(function (c) {\n                          return c.id === event.valueId\n                        })\n                        if (pos >= 0) {\n                          this._content[pos].dom = newNode\n                          _tryInsertDom(pos)\n                        }\n                      })\n                    })\n                  }\n                } else if (event.type === 'childRemoved') {\n                  var d = event._content.dom\n                  if (d != null) {\n                    d.remove()\n                  }\n                  _tryInsertDom(event.index - 1)\n                }\n              })\n            })\n          })\n          resolve(dom)\n        })\n      }\n      _setDom (dom) {\n        if (this.dom != null) {\n          throw new Error('Only call this method if you know what you are doing ;)')\n        } else if (dom.__yxml != null) { // TODO do i need to check this? - no.. but for dev purps..\n          throw new Error('Already bound to an YXml type')\n        } else {\n          dom.__yxml = this._model\n          // tag is already set in constructor\n          // set attributes\n          for (var i = 0; i < dom.attributes.length; i++) {\n            var attr = dom.attributes[i]\n            this.attributes.set(attr.name, attr.value)\n          }\n          this.insert(0, Array.prototype.map.call(dom.childNodes, function (c, i) {\n            if (c instanceof window.Element) {\n              return Y.Xml(c)\n            } else if (c instanceof window.Text) {\n              return c.textContent\n            } else {\n              throw new Error('Unknown node type!')\n            }\n          }))\n          Array.prototype.forEach.call(dom.childNodes, (dom, i) => {\n            var c = this._content[i]\n            c.dom = dom\n            c.isInserted = true\n          })\n          this.dom = this._bindToDom(dom)\n          return this.dom\n        }\n        return this.dom\n      }\n      getDom () {\n        if (this.dom == null) {\n          var dom = document.createElement(this.tagname)\n          dom.__yxml = this\n          this.attributes.keysPrimitives().forEach(key => {\n            dom.setAttribute(key, this.attributes.get(key))\n          })\n          return new Promise((resolve) => {\n            var self = this\n            this.os.requestTransaction(function *() {\n              var children = [] // <Promise([dom, content_i])>\n              for (var i = 0; i < self._content.length; i++) {\n                let c = self._content[i]\n                if (c.hasOwnProperty('val')) {\n                  children.push([new window.Text(c.val), c])\n                } else {\n                  var type = yield* this.getType(c.type)\n                  children.push(type.getDom().then(function (dom) {\n                    return [dom, c]\n                  }))\n                }\n              }\n              self.dom = self._bindToDom(dom)\n              Promise.all(children).then(function (inserts) {\n                self._mutualExclude(function () {\n                  inserts.forEach(function (ins, i) {\n                    // need to find position again, because this could be deleted (though this is very unlikely)\n                    var pos\n                    if (self._content[i] === ins[1]) {\n                      // likeliest case\n                      pos = i\n                    } else {\n                      // find content again\n                      pos = self._content.findIndex(function (c) {\n                        return c === ins[1]\n                      })\n                    }\n                    if (pos >= 0) {\n                      // not deleted, insert dom\n                      ins[1].dom = ins[0]\n                      self._tryInsertDom(pos)\n                    }\n                  })\n                  self.dom.then(resolve)\n                })\n              })\n            })\n          })\n        }\n        return this.dom\n      }\n      observe (f) {\n        this._eventListenerHandler.addEventListener(f)\n      }\n      unobserve (f) {\n        this._eventListenerHandler.removeEventListener(f)\n      }\n      * _changed () {\n        if (this._domObserver != null) {\n          this._domObserverListener(this._domObserver.takeRecords())\n        }\n        yield* Y.Array.typeDefinition['class'].prototype._changed.apply(this, arguments)\n      }\n    }\n    Y.extend('Xml', new Y.utils.CustomType({\n      name: 'Xml',\n      class: YXml,\n      struct: 'List',\n      parseArguments: function (arg) {\n        if (typeof arg === 'string') {\n          return [this, {\n            tagname: arg\n          }]\n        } else if (arg instanceof window.Element) {\n          return [this, {\n            tagname: arg.tagName,\n            dom: arg\n          }]\n        } else {\n          throw new Error('Y.Xml requires an argument which is a string!')\n        }\n      },\n      appendAdditionalInfo: function * (op, init) {\n        var id = null\n        if (op.id[0] === '_') {\n          var typestruct = Y.Map.typeDefinition.struct\n          id = ['_', typestruct + '_' + 'Map_' + op.id[1]]\n        }\n        var properties = yield* this.createType(Y.Map(), id)\n        op.info = {\n          tagname: init.tagname\n        }\n        op.requires = [properties._model] // XML requires that 'properties' exists\n      },\n      initType: function * YXmlInitializer (os, model, init) {\n        var _content = yield* Y.Struct.List.map.call(this, model, function (op) {\n          var c = {\n            id: JSON.stringify(op.id)\n          }\n          if (op.hasOwnProperty('opContent')) {\n            c.type = op.opContent\n          } else {\n            c.val = op.content\n          }\n          return c\n        })\n        var properties = yield* this.getType(model.requires[0]) // get the only required op\n        return new YXml(os, model.id, _content, properties, model.info.tagname, init)\n      }\n    }))\n  })\n}\n\nmodule.exports = extend\nif (typeof Y !== 'undefined') {\n  extend(Y)\n}\n"]}