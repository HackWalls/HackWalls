{"version":3,"sources":["../yjs/node_modules/browserify/node_modules/browser-pack/_prelude.js","src/IndexedDB.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"y-indexeddb.es6","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* global Y */\n'use strict'\n\nfunction extend (Y) {\n  Y.requestModules(['memory']).then(function () {\n    class Store {\n      constructor (transaction, name) {\n        this.store = transaction.objectStore(name)\n      }\n      * find (id) {\n        return yield this.store.get(id)\n      }\n      * put (v) {\n        yield this.store.put(v)\n      }\n      * delete (id) {\n        yield this.store.delete(id)\n      }\n      * findWithLowerBound (start) {\n        return yield this.store.openCursor(window.IDBKeyRange.lowerBound(start))\n      }\n      * findWithUpperBound (end) {\n        return yield this.store.openCursor(window.IDBKeyRange.upperBound(end), 'prev')\n      }\n      * findNext (id) {\n        return yield* this.findWithLowerBound([id[0], id[1] + 1])\n      }\n      * findPrev (id) {\n        return yield* this.findWithUpperBound([id[0], id[1] - 1])\n      }\n      * iterate (t, start, end, gen) {\n        var range = null\n        if (start != null && end != null) {\n          range = window.IDBKeyRange.bound(start, end)\n        } else if (start != null) {\n          range = window.IDBKeyRange.lowerBound(start)\n        } else if (end != null) {\n          range = window.IDBKeyRange.upperBound(end)\n        }\n        var cursorResult\n        if (range != null) {\n          cursorResult = this.store.openCursor(range)\n        } else {\n          cursorResult = this.store.openCursor()\n        }\n        while ((yield cursorResult) != null) {\n          yield* gen.call(t, cursorResult.result.value)\n          cursorResult.result.continue()\n        }\n      }\n      * flush () {}\n    }\n\n    function createStoreClone (Store) {\n      class Clone extends Store {\n        constructor () {\n          super(...arguments)\n          this.buffer = []\n          this._copyTo = null\n        }\n        // copy to this store\n        // it may be neccessary to reset this every time you create a transaction\n        copyTo (store) {\n          this._copyTo = store\n          return this\n        }\n        * put (v, dontCopy) {\n          if (!dontCopy) {\n            this.buffer.push(this._copyTo.put(v))\n          }\n          yield* super.put(v)\n        }\n        * delete (id) {\n          this.buffer.push(this._copyTo.delete(id))\n          yield* super.delete(id)\n        }\n        * flush () {\n          yield* super.flush()\n          for (var i = 0; i < this.buffer.length; i++) {\n            yield* this.buffer[i]\n          }\n          yield* this._copyTo.flush()\n        }\n      }\n      return Clone\n    }\n    Y.utils.createStoreClone = createStoreClone\n\n    var BufferedStore = Y.utils.createSmallLookupBuffer(Store)\n    var ClonedStore = Y.utils.createStoreClone(Y.utils.RBTree)\n\n    class Transaction extends Y.Transaction {\n      constructor (store) {\n        super(store)\n        var transaction = store.db.transaction(['OperationStore', 'StateStore', 'DeleteStore'], 'readwrite')\n        this.store = store\n        this.ss = new BufferedStore(transaction, 'StateStore')\n        this.os = new BufferedStore(transaction, 'OperationStore')\n        this._ds = new BufferedStore(transaction, 'DeleteStore')\n        this.ds = store.dsClone.copyTo(this._ds)\n      }\n    }\n    class OperationStore extends Y.AbstractDatabase {\n      constructor (y, options) {\n        super(y, options)\n        // dsClone is persistent over transactions!\n        // _ds is not\n        this.dsClone = new ClonedStore()\n\n        if (options == null) {\n          options = {}\n        }\n        this.options = options\n        if (options.namespace == null) {\n          if (y.options.connector.room == null) {\n            throw new Error('IndexedDB: expect a string (options.namespace)! (you can also skip this step if your connector has a room property)')\n          } else {\n            options.namespace = y.options.connector.room\n          }\n        }\n        if (options.idbVersion != null) {\n          this.idbVersion = options.idbVersion\n        } else {\n          this.idbVersion = 5\n        }\n        var store = this\n        // initialize database!\n        this.requestTransaction(function * () {\n          store.db = yield window.indexedDB.open(options.namespace, store.idbVersion)\n        })\n        if (options.cleanStart) {\n          delete window.localStorage[JSON.stringify(['Yjs_indexeddb', options.namespace])]\n          this.requestTransaction(function * () {\n            yield this.os.store.clear()\n            yield this._ds.store.clear()\n            yield this.ss.store.clear()\n          })\n        }\n        this.whenUserIdSet(function (userid) {\n          if (window.localStorage[JSON.stringify(['Yjs_indexeddb', options.namespace])] == null) {\n            window.localStorage[JSON.stringify(['Yjs_indexeddb', options.namespace])] = JSON.stringify([userid, 0])\n          }\n        })\n        this.requestTransaction(function * () {\n          // this should be executed after the previous two defined transactions\n          // after we computed the upgrade event (see `yield indexedDB.open(..)`), we can check if userid is still stored on localstorage\n          var uid = window.localStorage[JSON.stringify(['Yjs_indexeddb', options.namespace])]\n          if (uid != null) {\n            store.setUserId(uid)\n            var nextuid = JSON.parse(uid)\n            nextuid[1] = nextuid[1] + 1\n            window.localStorage[JSON.stringify(['Yjs_indexeddb', options.namespace])] = JSON.stringify(nextuid)\n          }\n          // copy from persistent Store to not persistent StoreClone. (there could already be content in Store)\n          yield* this._ds.iterate(this, null, null, function * (o) {\n            yield* this.ds.put(o, true)\n          })\n        })\n        this.operationAddedNamespace = JSON.stringify(['__YJS__', this.options.namespace])\n        var operationsToAdd = []\n        window.addEventListener('storage', function (event) {\n          if (event.key === store.operationAddedNamespace) {\n            operationsToAdd.push(JSON.parse(event.newValue))\n            var op, i // helper variables\n            if (operationsToAdd.length === 1) {\n              store.requestTransaction(function * () {\n                /* about nextRound:\n                   if op is not a delete, we retrieve it again from the db\n                   then it could be true that op.left is not yet added to store\n                    - but the types _change function expects that it is..\n                   In this case left has to be executed first\n\n                   What is left to say: we only put ready to execute ops in nextRound!\n\n                   TODO: implement a smart buffer in eventHelper!!!!!\n                */\n                var nextRound = []\n                for (i = 0; i < operationsToAdd.length; i++) {\n                  op = operationsToAdd[i]\n                  if (op.struct !== 'Delete') {\n                    op = yield* this.getOperation(op.id)\n                    while (op.left != null) {\n                      var left = yield* this.getOperation(op.left)\n                      if (!left.deleted) {\n                        break\n                      }\n                      op.left = left.left\n                    }\n                  }\n                  nextRound.push(op)\n                }\n                operationsToAdd = []\n                while (nextRound.length > 0) {\n                  var add = nextRound\n                  nextRound = []\n                  for (i = 0; i < add.length; i++) {\n                    op = add[i]\n                    if (op.struct === 'Insert') {\n                      var ready = true\n                      for (let j = i + 1; j < add.length; j++) {\n                        let _op = add[j]\n                        if (Y.utils.compareIds(_op.id, op.left)) {\n                          ready = false\n                          break\n                        }\n                      }\n                      if (ready) {\n                        for (let j = 0; j < nextRound.length; j++) {\n                          let _op = add[j]\n                          if (Y.utils.compareIds(_op.id, op.left)) {\n                            ready = false\n                            break\n                          }\n                        }\n                      }\n                      if (!ready) {\n                        // it is necessary to execute left first\n                        nextRound.push(op)\n                        continue\n                      }\n                    }\n                    yield* this.store.operationAdded(this, op, true)\n                  }\n                }\n              })\n            }\n          }\n        }, false)\n      }\n      * operationAdded (transaction, op, noAdd) {\n        yield* super.operationAdded(transaction, op)\n        if (!noAdd) {\n          window.localStorage[this.operationAddedNamespace] = JSON.stringify(op)\n        }\n      }\n      transact (makeGen) {\n        var transaction = this.db != null ? new Transaction(this) : null\n        var store = this\n\n        var gen = makeGen.call(transaction)\n        handleTransactions(gen.next())\n\n        function handleTransactions (result) {\n          var request = result.value\n          if (result.done) {\n            makeGen = store.getNextRequest()\n            if (makeGen != null) {\n              if (transaction == null && store.db != null) {\n                transaction = new Transaction(store)\n              }\n              gen = makeGen.call(transaction)\n              handleTransactions(gen.next())\n            } // else no transaction in progress!\n            return\n          }\n          console.log('new request', request.source != null ? request.source.name : null)\n          if (request.constructor === window.IDBRequest) {\n            request.onsuccess = function () {\n              var res = request.result\n              if (res != null && res.constructor === window.IDBCursorWithValue) {\n                res = res.value\n              }\n              handleTransactions(gen.next(res))\n            }\n            request.onerror = function (err) {\n              gen.throw(err)\n            }\n          } else if (request.constructor === window.IDBCursor) {\n            request.onsuccess = function () {\n              handleTransactions(gen.next(request.result != null ? request.result.value : null))\n            }\n            request.onerror = function (err) {\n              gen.throw(err)\n            }\n          } else if (request.constructor === window.IDBOpenDBRequest) {\n            request.onsuccess = function (event) {\n              var db = event.target.result\n              handleTransactions(gen.next(db))\n            }\n            request.onerror = function () {\n              gen.throw(\"Couldn't open IndexedDB database!\")\n            }\n            request.onupgradeneeded = function (event) {\n              var db = event.target.result\n              try {\n                delete window.localStorage[JSON.stringify(['Yjs_indexeddb', store.options.namespace])]\n                db.deleteObjectStore('OperationStore')\n                db.deleteObjectStore('DeleteStore')\n                db.deleteObjectStore('StateStore')\n              } catch (e) {}\n              db.createObjectStore('OperationStore', {keyPath: 'id'})\n              db.createObjectStore('DeleteStore', {keyPath: 'id'})\n              db.createObjectStore('StateStore', {keyPath: 'id'})\n            }\n          } else {\n            gen.throw('You must not yield this type!')\n          }\n        }\n      }\n      // TODO: implement \"free\"..\n      * destroy () {\n        this.db.close()\n        yield window.indexedDB.deleteDatabase(this.options.namespace)\n      }\n    }\n    Y.extend('indexeddb', OperationStore)\n  })\n}\n\nmodule.exports = extend\nif (typeof Y !== 'undefined') {\n  extend(Y)\n}\n"]}