{"version":3,"sources":["../yjs/node_modules/browserify/node_modules/browser-pack/_prelude.js","src/Richtext.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"y-richtext.es6","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* global Y */\n'use strict'\n\nfunction extend (Y) {\n  Y.requestModules(['Array']).then(function () {\n    class YRichtext extends Y.Array.typeDefinition['class'] {\n      constructor (os, _model, _content) {\n        super(os, _model, _content)\n        this.instances = []\n      }\n      _destroy () {\n        for (var i = this.instances.length - 1; i >= 0; i--) {\n          this.unbindQuill(this.instances[i].editor)\n        }\n        super._destroy()\n      }\n      get length () {\n        /*\n          TODO: I must not use observe to compute the length.\n          But since I inherit from Y.Array, I can't set observe\n          the changes at the right momet (for that I would require direct access to EventHandler).\n          This is the most elegant solution, for now.\n          But at some time you should re-write Y.Richtext more elegantly!!\n        */\n        return this.toString().length\n      }\n      toString () {\n        return this._content.map(function (v) {\n          if (typeof v.val === 'string') {\n            return v.val\n          }\n        }).join('')\n      }\n      toOTOps () {\n        var ops = []\n        var op = {\n          insert: [],\n          attributes: {}\n        }\n        function createNewOp () {\n          var attrs = {}\n          // copy attributes\n          for (var name in op.attributes) {\n            attrs[name] = op.attributes[name]\n          }\n          op = {\n            insert: [],\n            attributes: attrs\n          }\n        }\n        var i = 0\n        for (; i < this._content.length; i++) {\n          let v = this._content[i].val\n          if (v.constructor === Array) {\n            if (op.insert.length > 0) {\n              op.insert = op.insert.join('')\n              ops.push(op)\n              createNewOp()\n            }\n            if (v[1] === null) {\n              delete op.attributes[v[0]]\n            } else {\n              op.attributes[v[0]] = v[1]\n            }\n          } else {\n            op.insert.push(v)\n          }\n        }\n        if (op.insert.length > 0) {\n          op.insert = op.insert.join('')\n          ops.push(op)\n        }\n        return ops\n      }\n      insert (pos, content) {\n        var curPos = 0\n        var selection = {}\n        for (var i = 0; i < this._content.length; i++) {\n          if (curPos === pos) {\n            break\n          }\n          var v = this._content[i].val\n          if (typeof v === 'string') {\n            curPos++\n          } else if (v.constructor === Array) {\n            if (v[1] === null) {\n              delete selection[v[0]]\n            } else {\n              selection[v[0]] = v[1]\n            }\n          }\n        }\n        super.insert(i, content.split(''))\n        return selection\n      }\n      delete (pos, length) {\n        /*\n          let x = to be deleted string\n          let s = some string\n          let * = some selection\n          E.g.\n          sss*s***x*xxxxx***xx*x**ss*s\n               |---delete-range--|\n             delStart         delEnd\n\n          We'll check the following\n          * is it possible to delete some of the selections?\n            1. a dominating selection to the right could be the same as the selection (curSel) to delStart\n            2. a selections could be overwritten by another selection to the right\n        */\n        var curPos = 0\n        var curSel = {}\n        var endPos = pos + length\n        if (length <= 0) return\n        var delStart // relative to _content\n        var delEnd // ..\n        var v, i // helper variable for elements of _content\n\n        for (delStart = 0; curPos < pos && delStart < this._content.length; delStart++) {\n          v = this._content[delStart].val\n          if (typeof v === 'string') {\n            curPos++\n          } else if (v.constructor === Array) {\n            curSel[v[0]] = v[1]\n          }\n        }\n        for (delEnd = delStart; curPos < endPos && delEnd < this._content.length; delEnd++) {\n          v = this._content[delEnd].val\n          if (typeof v === 'string') {\n            curPos++\n          }\n        }\n        if (delEnd === this._content.length) {\n          // yay, you can delete everything without checking\n          for (i = delEnd - 1; i >= delStart; i--) {\n            v = this._content[i].val\n            super.delete(i, 1)\n          }\n        } else {\n          if (typeof v === 'string') {\n            delEnd--\n          }\n          var rightSel = {}\n          for (i = delEnd; i >= delStart; i--) {\n            v = this._content[i].val\n            if (v.constructor === Array) {\n              if (rightSel[v[0]] === undefined) {\n                if (v[1] === curSel[v[0]]) {\n                  // case 1.\n                  super.delete(i, 1)\n                }\n                rightSel[v[0]] = v[1]\n              } else {\n                // case 2.\n                super.delete(i, 1)\n              }\n            } else if (typeof v === 'string') {\n              // always delete the strings\n              super.delete(i, 1)\n            }\n          }\n        }\n      }\n      /*\n      1. get selection attributes from position $from\n         (name it antiAttrs, and we'll use it to make sure that selection ends in antiAttrs)\n      2. Insert selection $attr, if necessary\n      3. Between from and to, we'll delete all selections that do not match $attr.\n         Furthermore, we'll update antiAttrs, if necessary\n      4. In the end well insert a selection that makes sure that selection($to) ends in antiAttrs\n      */\n      select (from, to, attrName, attrValue) {\n        if (from == null || to == null || attrName == null || attrValue === undefined) {\n          throw new Error('You must define four parameters')\n        } else {\n          var step2i\n          var step2sel\n          var antiAttrs = [attrName, null]\n          var curPos = 0\n          var i = 0\n          // 1. compute antiAttrs\n          for (; i < this._content.length; i++) {\n            let v = this._content[i].val\n            if (curPos === from) {\n              break\n            }\n            if (v.constructor === Array) {\n              if (v[0] === attrName) {\n                antiAttrs[1] = v[1]\n              }\n            } else if (typeof v === 'string') {\n              curPos++\n            }\n          }\n          // 2. Insert attr\n          if (antiAttrs[1] !== attrValue) {\n            // we'll execute this later\n            step2i = i\n            step2sel = [attrName, attrValue]\n          }\n\n          // 3. update antiAttrs, modify selection\n          var deletes = []\n          for (; i < this._content.length; i++) {\n            let v = this._content[i].val\n            if (curPos === to) {\n              break\n            }\n            if (v.constructor === Array) {\n              if (v[0] === attrName) {\n                antiAttrs[1] = v[1]\n                deletes.push(i)\n              }\n            } else if (typeof v === 'string') {\n              curPos++\n            }\n          }\n          // actually delete the found selections\n          // also.. we have to delete from right to left (so that the positions dont change)\n          for (var j = deletes.length - 1; j >= 0; j--) {\n            var del = deletes[j]\n            super.delete(del, 1)\n            // update i, rel. to\n            if (del < i) {\n              i--\n            }\n            if (del < step2i) {\n              step2i--\n            }\n          }\n          // 4. Update selection to match antiAttrs\n          // never insert, if not necessary\n          //  1. when it is the last position ~ i < _content.length)\n          //  2. when a similar attrName already exists between i and the next character\n          if (antiAttrs[1] !== attrValue && i < this._content.length) { // check 1.\n            var performStep4 = true\n            var v\n            for (j = i; j < this._content.length; j++) {\n              v = this._content[j].val\n              if (v.constructor !== Array) {\n                break\n              }\n              if (v[0] === attrName) {\n                performStep4 = false // check 2.\n                if (v[1] === attrValue) {\n                  super.delete(j, 1)\n                }\n                break\n              }\n            }\n            if (performStep4) {\n              var sel = [attrName, antiAttrs[1]]\n              super.insert(i, [sel])\n            }\n          }\n          if (step2i != null) {\n            super.insert(step2i, [step2sel])\n            // if there are some selections to the left of step2sel, delete them if possible\n            // * have same attribute name\n            // * no insert between step2sel and selection\n            for (j = step2i - 1; j >= 0; j--) {\n              v = this._content[j].val\n              if (v.constructor !== Array) {\n                break\n              }\n              if (v[0] === attrName) {\n                super.delete(j, 1)\n              }\n            }\n          }\n        }\n      }\n      bind () {\n        this.bindQuill.apply(this, arguments)\n      }\n      unbindQuill (quill) {\n        var i = this.instances.findIndex(function (binding) {\n          return binding.editor === quill\n        })\n        if (i >= 0) {\n          var binding = this.instances[i]\n          this.unobserve(binding.yCallback)\n          binding.editor.off('text-change', binding.quillCallback)\n          this.instances.splice(i, 1)\n        }\n      }\n      bindQuill (quill) {\n        var self = this\n\n        // this function makes sure that either the\n        // quill event is executed, or the yjs observer is executed\n        var token = true\n        function mutualExcluse (f) {\n          if (token) {\n            token = false\n            try {\n              f()\n            } catch (e) {\n              token = true\n              throw new Error(e)\n            }\n            token = true\n          }\n        }\n\n        quill.setContents(this.toOTOps())\n\n        function quillCallback (delta) {\n          mutualExcluse(function () {\n            var pos = 0\n            var name // helper variable\n            for (var i = 0; i < delta.ops.length; i++) {\n              var op = delta.ops[i]\n              if (op.insert != null) {\n                var attrs = self.insert(pos, op.insert)\n                // create new selection\n                for (name in op.attributes) {\n                  if (op.attributes[name] !== attrs[name]) {\n                    self.select(pos, pos + op.insert.length, name, op.attributes[name])\n                  }\n                }\n                // not-existence of an attribute in op.attributes denotes\n                // that we have to unselect (set to null)\n                for (name in attrs) {\n                  if (op.attributes == null || attrs[name] !== op.attributes[name]) {\n                    self.select(pos, pos + op.insert.length, name, null)\n                  }\n                }\n                pos += op.insert.length\n              }\n              if (op.delete != null) {\n                self.delete(pos, op.delete)\n              }\n              if (op.retain != null) {\n                var afterRetain = pos + op.retain\n                if (afterRetain > self.length) {\n                  let additionalContent = quill.getText(self.length)\n                  quill.insertText(self.length, additionalContent)\n                  // quill.deleteText(self.length + additionalContent.length, quill.getLength())\n                  for (name in op.attributes) {\n                    quill.formatText(self.length + additionalContent.length, self.length + additionalContent.length * 2, name, null)\n                    // quill.deleteText(self.length, self.length + op.retain)\n                  }\n                  self.insert(self.length, additionalContent)\n                  // op.attributes = null\n                }\n                for (name in op.attributes) {\n                  self.select(pos, pos + op.retain, name, op.attributes[name])\n                  quill.formatText(pos, pos + op.retain, name, op.attributes[name])\n                }\n                pos = afterRetain\n              }\n            }\n          })\n        }\n        quill.on('text-change', quillCallback)\n\n        function yCallback (events) {\n          mutualExcluse(function () {\n            var v // helper variable\n            var curSel // helper variable (current selection)\n            for (var i = 0; i < events.length; i++) {\n              var event = events[i]\n              if (event.type === 'insert') {\n                if (typeof event.value === 'string') {\n                  var position = 0\n                  var insertSel = {}\n                  for (var l = event.index - 1; l >= 0; l--) {\n                    v = self._content[l].val\n                    if (typeof v === 'string') {\n                      position++\n                    } else if (v.constructor === Array && typeof insertSel[v[0]] === 'undefined') {\n                      insertSel[v[0]] = v[1]\n                    }\n                  }\n                  quill.insertText(position, event.value, insertSel)\n                } else if (event.value.constructor === Array) {\n                  // a new selection is created\n                  // find left selection that matches newSel[0]\n                  curSel = null\n                  var newSel = event.value\n                  // denotes the start position of the selection\n                  // (without the selection objects)\n                  var selectionStart = 0\n                  for (var j = event.index - 1; j >= 0; j--) {\n                    v = self._content[j].val\n                    if (v.constructor === Array) {\n                      // check if v matches newSel\n                      if (newSel[0] === v[0]) {\n                        // found a selection\n                        // update curSel and go to next step\n                        curSel = v[1]\n                        break\n                      }\n                    } else if (typeof v === 'string') {\n                      selectionStart++\n                    }\n                  }\n                  // make sure to decrement j, so we correctly compute selectionStart\n                  for (; j >= 0; j--) {\n                    v = self._content[j].val\n                    if (typeof v === 'string') {\n                      selectionStart++\n                    }\n                  }\n                  // either a selection was found {then curSel was updated}, or not (then curSel = null)\n                  if (newSel[1] === curSel) {\n                    // both are the same. not necessary to do anything\n                    return\n                  }\n                  // now find out the range over which newSel has to be created\n                  var selectionEnd = selectionStart\n                  for (var k = event.index + 1; k < self._content.length; k++) {\n                    v = self._content[k].val\n                    if (v.constructor === Array) {\n                      if (v[0] === newSel[0]) {\n                        // found another selection with same attr name\n                        break\n                      }\n                    } else if (typeof v === 'string') {\n                      selectionEnd++\n                    }\n                  }\n                  // create a selection from selectionStart to selectionEnd\n                  if (selectionStart !== selectionEnd) {\n                    quill.formatText(selectionStart, selectionEnd, newSel[0], newSel[1])\n                  }\n                }\n              } else if (event.type === 'delete') {\n                if (typeof event.value === 'string') { // TODO: see button. add  || `event.length > 1`\n                  // only if these conditions are true, we have to actually check if we have to delete sth.\n                  // Then we have to check if between pos and pos + event.length are selections:\n                  // delete till pos + (event.length - number of selections)\n                  var pos = 0\n                  for (var u = 0; u < event.index; u++) {\n                    v = self._content[u].val\n                    if (typeof v === 'string') {\n                      pos++\n                    }\n                  }\n                  var delLength = event.length\n                  /* TODO!!\n                  they do not exist anymore.. so i can't query. you have to query over event.value(s) - but that not yet implemented\n                  for (; i < event.index + event.length; i++) {\n                    if (self._content[i].val.constructor === Array) {\n                      delLength--\n                    }\n                  }*/\n                  quill.deleteText(pos, pos + delLength)\n                } else if (event.value.constructor === Array) {\n                  curSel = null\n                  var from = 0\n                  var x\n                  for (x = event.index - 1; x >= 0; x--) {\n                    v = self._content[x].val\n                    if (v.constructor === Array) {\n                      if (v[0] === event.value[0]) {\n                        curSel = v[1]\n                        break\n                      }\n                    } else if (typeof v === 'string') {\n                      from++\n                    }\n                  }\n                  for (; x >= 0; x--) {\n                    v = self._content[x].val\n                    if (typeof v === 'string') {\n                      from++\n                    }\n                  }\n                  var to = from\n                  for (x = event.index; x < self._content.length; x++) {\n                    v = self._content[x].val\n                    if (v.constructor === Array) {\n                      if (v[0] === event.value[0]) {\n                        break\n                      }\n                    } else if (typeof v === 'string') {\n                      to++\n                    }\n                  }\n                  if (curSel !== event.value[1] && from !== to) {\n                    quill.formatText(from, to, event.value[0], curSel)\n                  }\n                }\n              }\n            }\n            quill.editor.checkUpdate()\n          })\n        }\n        this.observe(yCallback)\n        this.instances.push({\n          editor: quill,\n          yCallback: yCallback,\n          quillCallback: quillCallback\n        })\n      }\n      * _changed () {\n        this.instances.forEach(function (instance) {\n          instance.editor.editor.checkUpdate()\n        })\n        yield* Y.Array.typeDefinition['class'].prototype._changed.apply(this, arguments)\n      }\n    }\n    Y.extend('Richtext', new Y.utils.CustomType({\n      name: 'Richtext',\n      class: YRichtext,\n      struct: 'List',\n      initType: function * YTextInitializer (os, model) {\n        var _content = yield* Y.Struct.List.map.call(this, model, function (c) {\n          return {\n            id: JSON.stringify(c.id),\n            val: c.content\n          }\n        })\n        return new YRichtext(os, model.id, _content)\n      }\n    }))\n  })\n}\n\nmodule.exports = extend\nif (typeof Y !== 'undefined') {\n  extend(Y)\n}\n"]}